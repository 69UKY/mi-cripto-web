<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GALAXY FINANCIAL</title>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: black;
  font-family: Arial, Helvetica, sans-serif;
  color: white;
}

/* UI SUPERIOR */
#ui {
  #ui h1 {
  display: none;
 }

  position: absolute;
  top: 20px;
  width: 100%;
  text-align: center;
  z-index: 10;
  pointer-events: none;
}

/* CTA */
#cta{
  position: absolute;
  bottom: 40px;
  width: 100%;
  text-align: center;
  z-index: 10;
}

.btn{
  display: inline-block;
  margin: 0 10px;
  padding: 14px 30px;
  border: 2px solid white;
  color: white;
  text-decoration: none;
  font-weight: bold;
  transition: .3s;
}

.btn:hover{
  background:white;
  color:black;
}

.btn.ghost{
  opacity:.7;
}

/* PANEL HTML */
.panel {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.25);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);


  -webkit-backdrop-filter: blur(12px);
  display: none;
  z-index: 20;
  padding: 60px 10%;
  overflow-y: auto;
}

.panel h2 {
  font-size: 42px;
  margin-bottom: 20px;
}

.panel p, .panel li {
  font-size: 18px;
  line-height: 1.6;
  opacity: 0.9;
}

.close {
  position: absolute;
  top: 20px;
  right: 30px;
  font-size: 28px;
  cursor: pointer;
}
/* ğŸ APPLE EVENT STYLE */
#eventIntro {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, #050505, #000);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
  animation: fadeOutIntro 2s ease forwards;
  animation-delay: 4.5s;
}

#eventTitle {
  font-size: 64px;
  letter-spacing: 10px;
  opacity: 0;
  animation: slideUp 1.8s ease forwards;
}

#eventSubtitle {
  margin-top: 20px;
  font-size: 20px;
  opacity: 0.6;
  letter-spacing: 3px;
  opacity: 0;
  animation: slideUp 1.8s ease forwards;
  animation-delay: 0.8s;
}

/* ANIMACIONES */
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@keyframes fadeOutIntro {
  to {
    opacity: 0;
    pointer-events: none;
  }
}
/* âœ¨ TÃTULO INTERACTIVO PROFESIONAL */
#mainTitle {
  font-size: 48px;
  letter-spacing: 6px;
  text-transform: uppercase;
  background: linear-gradient(120deg, #ffffff, #9cc9ff, #ffffff);
  background-size: 200% auto;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;

  filter: drop-shadow(0 0 15px rgba(140,180,255,0.35));
  transition: transform 0.25s ease, filter 0.25s ease;
  animation: titleGlow 6s ease-in-out infinite;
}

/* AnimaciÃ³n sutil */
@keyframes titleGlow {
  0% { background-position: 0% center; }
  50% { background-position: 100% center; }
  100% { background-position: 0% center; }
}

</style>
</head>

<body>
 <!-- ğŸ APPLE EVENT INTRO -->
<div id="eventIntro">
  <h1 id="eventTitle">GALAXY FINANCIAL</h1>
  <p id="eventSubtitle">The Future of Decentralized Finance</p>
  
</div>

<div id="ui">
  <h1 id="mainTitle">GALAXY FINANCIAL</h1>
  <p>Una galaxia financiera en expansiÃ³n</p>
  
</div>



<!-- ABOUT -->
<div id="aboutPanel" class="panel">
  <div class="close" onclick="closePanels()">âœ–</div>
  <h2>ğŸŒŒ ABOUT</h2>
  <p>
    GALAXY FINANCIAL is a decentralized digital asset designed to power
    a next-generation financial ecosystem focused on transparency,
    scalability and community-driven growth.
  </p>
</div>

<!-- UTILITY -->

<div id="utilityPanel" class="panel">
  <div class="close" onclick="closePanels()">âœ–</div>
  <h2>âš™ï¸ TOKEN UTILITY</h2>
  <ul>
    <li>ğŸ’ Governance & voting rights</li>
    <li>ğŸ”¥ Deflationary mechanics</li>
    <li>ğŸ¦ Staking rewards</li>
    <li>ğŸª™ Ecosystem payments</li>
    <li>ğŸš€ Future DeFi integrations</li>
  </ul>
</div>

<!-- SECURITY -->
<div id="securityPanel" class="panel">
  <div class="close" onclick="closePanels()">âœ–</div>
  <h2>ğŸ” SECURITY</h2>
  <ul>
    <li>âœ… Verified Smart Contract</li>
    <li>ğŸ”’ Liquidity Lock</li>
    <li>ğŸ›¡ï¸ Anti-bot protection</li>
    <li>ğŸ“œ Public contract address</li>
  </ul>
</div>

<!-- TOKENOMICS -->
<div id="tokenomicsPanel" class="panel">
  <div class="close" onclick="closePanels()">âœ–</div>
  <h2>ğŸ“Š TOKENOMICS</h2>
  <ul>
    <li>ğŸ”¥ 40% Liquidez</li>
    <li>ğŸš€ 25% Desarrollo</li>
    <li>ğŸ¯ 20% Marketing</li>
    <li>ğŸ¦ 10% Staking</li>
    <li>ğŸ‘¥ 5% Equipo</li>
  </ul>
</div>

<!-- ROADMAP -->
<div id="roadmapPanel" class="panel">
  <div class="close" onclick="closePanels()">âœ–</div>
  <h2>ğŸ›£ï¸ ROADMAP</h2>
  <ul>
    <li>âœ… Phase 1 â€“ Token Launch</li>
    <li>âœ… Phase 2 â€“ Website & Community</li>
    <li>ğŸš§ Phase 3 â€“ Exchange Listings</li>
    <li>ğŸ”œ Phase 4 â€“ Staking & NFT</li>
    <li>ğŸŒŒ Phase 5 â€“ Full Ecosystem</li>
  </ul>
</div>


<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

<script>
/* ESCENA */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,6,18);
// ======================
// ğŸ¥ CINEMÃTICA DE ENTRADA
// ======================
let introProgress = 0;
let introDuration = 220; // cuanto mÃ¡s alto, mÃ¡s lenta
let introFinished = false;

// posiciÃ³n inicial (muy lejos)
const introStart = new THREE.Vector3(-120, 30, 120);

// posiciÃ³n final (la que ya usabas)
const introEnd = new THREE.Vector3(0, 6, 18);

// empezamos desde lejos
camera.position.copy(introStart);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* CONTROLES */
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enablePan = false;
controls.enabled = false;

/* LUCES */
scene.add(new THREE.AmbientLight(0xffffff,0.6));
const light = new THREE.PointLight(0x88aaff,2,300);
light.position.set(10,15,10);
scene.add(light);

// ======================
// ğŸŒŒ NEBULOSA DE FONDO
// ======================

const nebulaGeometry = new THREE.BufferGeometry();
const nebulaCount = 5000;
const nebulaPositions = new Float32Array(nebulaCount * 3);
const nebulaColors = new Float32Array(nebulaCount * 3);

const nebulaColor1 = new THREE.Color(0x4455ff); // azul
const nebulaColor2 = new THREE.Color(0xaa66ff); // violeta

for (let i = 0; i < nebulaCount; i++) {
  const i3 = i * 3;

  const r = Math.random() * 200 + 80;

  nebulaPositions[i3]     = (Math.random() - 0.5) * r;
  nebulaPositions[i3 + 1] = (Math.random() - 0.5) * r;
  nebulaPositions[i3 + 2] = (Math.random() - 0.5) * r;

  const mixed = nebulaColor1.clone();
  mixed.lerp(nebulaColor2, Math.random());

  nebulaColors[i3]     = mixed.r;
  nebulaColors[i3 + 1] = mixed.g;
  nebulaColors[i3 + 2] = mixed.b;
}

nebulaGeometry.setAttribute(
  "position",
  new THREE.BufferAttribute(nebulaPositions, 3)
);

nebulaGeometry.setAttribute(
  "color",
  new THREE.BufferAttribute(nebulaColors, 3)
);

const nebulaMaterial = new THREE.PointsMaterial({
  size: 2.5,
  transparent: true,
  opacity: 0.08,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  vertexColors: true
});

const nebula = new THREE.Points(nebulaGeometry, nebulaMaterial);
scene.add(nebula);
// ======================
// ğŸŒ  NUBES VOLUMÃ‰TRICAS
// ======================

const cloudGeometry = new THREE.BufferGeometry();
const cloudCount = 4000;
const cloudPositions = new Float32Array(cloudCount * 3);
const cloudColors = new Float32Array(cloudCount * 3);

const cloudColor1 = new THREE.Color(0x2233ff);
const cloudColor2 = new THREE.Color(0x6622aa);

for (let i = 0; i < cloudCount; i++) {
  const i3 = i * 3;

  const radius = 60 + Math.random() * 40;
  const angle = Math.random() * Math.PI * 2;

  cloudPositions[i3]     = Math.cos(angle) * radius + (Math.random() - 0.5) * 30;
  cloudPositions[i3 + 1] = (Math.random() - 0.5) * 20;
  cloudPositions[i3 + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * 30;

  const mixed = cloudColor1.clone();
  mixed.lerp(cloudColor2, Math.random());

  cloudColors[i3]     = mixed.r;
  cloudColors[i3 + 1] = mixed.g;
  cloudColors[i3 + 2] = mixed.b;
}

cloudGeometry.setAttribute(
  "position",
  new THREE.BufferAttribute(cloudPositions, 3)
);

cloudGeometry.setAttribute(
  "color",
  new THREE.BufferAttribute(cloudColors, 3)
);

const cloudMaterial = new THREE.PointsMaterial({
  size: 4,
  transparent: true,
  opacity: 0.06,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  vertexColors: true
});

const clouds = new THREE.Points(cloudGeometry, cloudMaterial);
scene.add(clouds);

/* GALAXIA */
const galaxyGeometry = new THREE.BufferGeometry();
const starCount = 120000;
const positions = new Float32Array(starCount * 3);
const colors = new Float32Array(starCount * 3);

const insideColor = new THREE.Color(0xffffff);
const outsideColor = new THREE.Color(0x3a66ff);

const radius = 40;
const randomness = 0.6;

for (let i = 0; i < starCount; i++) {
  const i3 = i * 3;
  const r = Math.random() * radius;

  positions[i3] = (Math.random()-0.5)*r*2;
  positions[i3+1] = (Math.random()-0.5)*r*0.5;
  positions[i3+2] = (Math.random()-0.5)*r*2;

  const mixed = insideColor.clone().lerp(outsideColor, r/radius);
  colors[i3]=mixed.r; colors[i3+1]=mixed.g; colors[i3+2]=mixed.b;
}

galaxyGeometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
galaxyGeometry.setAttribute('color', new THREE.BufferAttribute(colors,3));

const galaxyMaterial = new THREE.PointsMaterial({
  size:0.035,
  blending:THREE.AdditiveBlending,
  depthWrite:false,
  vertexColors:true
});

const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
scene.add(galaxy);
// ======================
// ğŸ”  TEXTO 3D CRISTAL
// ======================
const fontLoader = new THREE.FontLoader();

fontLoader.load(
  "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
  function (font) {

    const textGeometry = new THREE.TextGeometry("GALAXY FINANCIAL", {
      font: font,
      size: 1.2,
      height: 0.3,
      curveSegments: 16,
      bevelEnabled: true,
      bevelThickness: 0.03,
      bevelSize: 0.02,
      bevelSegments: 5
    });

    textGeometry.center();

    const textMaterial = new THREE.MeshPhysicalMaterial({
      color: 0xffffff,
      roughness: 0.1,
      transmission: 0.9,   // ğŸŒ«ï¸ cristal real
      thickness: 1.5,
      envMapIntensity: 1,
      clearcoat: 1,
      clearcoatRoughness: 0.1,
      transparent: true
    });

    window.title3D = new THREE.Mesh(textGeometry, textMaterial);
    title3D.position.set(0, 4.5, 0);
    scene.add(title3D);
  }
);

/* TEXTO CRISTAL 3D */
function textSprite(text) {
  const canvas = document.createElement("canvas");
  canvas.width = 512;
  canvas.height = 128;
  const ctx = canvas.getContext("2d");

  // Fondo cristal
  ctx.fillStyle = "rgba(255,255,255,0.08)";
  ctx.fillRect(0, 0, 512, 128);

  // Borde de cristal
  ctx.strokeStyle = "rgba(255,255,255,0.4)";
  ctx.lineWidth = 2;
  ctx.strokeRect(12, 12, 488, 104);

  // Brillo interno (glass glow)
  ctx.shadowColor = "rgba(255,255,255,0.6)";
  ctx.shadowBlur = 20;

  // Texto
  ctx.fillStyle = "white";
  ctx.font = "bold 44px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(text, 256, 64);

  const texture = new THREE.CanvasTexture(canvas);
  texture.anisotropy = 16;

  const material = new THREE.SpriteMaterial({
    map: texture,
    transparent: true,
    opacity: 0.85,
    depthWrite: false
  });

  const sprite = new THREE.Sprite(material);

  // IMPORTANTE: empieza invisible
  sprite.scale.set(0, 0, 1);

  return sprite;
}



const roadmap=textSprite("ROADMAP");
roadmap.position.set(-10,2,0);
scene.add(roadmap);
roadmap.userData = {
  appear: 0,
  delay: Math.random() * 0.6
};
roadmap.material.opacity = 0;
roadmap.scale.set(0.01, 0.01, 0.01);

const tokenomics=textSprite("TOKENOMICS");
tokenomics.position.set(10,2,0);
scene.add(tokenomics);
roadmap.userData = {
  appear: 0,
  delay: Math.random() * 0.6
};
roadmap.material.opacity = 0;
roadmap.scale.set(0.01, 0.01, 0.01);

const about=textSprite("ABOUT");
about.position.set(0,4,-6);
scene.add(about);
roadmap.userData = {
  appear: 0,
  delay: Math.random() * 0.6
};
roadmap.material.opacity = 0;
roadmap.scale.set(0.01, 0.01, 0.01);

const utility=textSprite("UTILITY");
utility.position.set(-6,1,-8);
scene.add(utility);
roadmap.userData = {
  appear: 0,
  delay: Math.random() * 0.6
};
roadmap.material.opacity = 0;
roadmap.scale.set(0.01, 0.01, 0.01);

const security=textSprite("SECURITY");
security.position.set(6,1,-8);
scene.add(security);
roadmap.userData = {
  appear: 0,
  delay: Math.random() * 0.6
};

const buyToken = textSprite("BUY TOKEN");
buyToken.position.set(-8,-2,5);
scene.add(buyToken);

const whitepaper = textSprite("WHITE PAPER");
whitepaper.position.set(6,-1,8);
scene.add(whitepaper);


const clickable=[roadmap,tokenomics,about,utility,security,buyToken,
  whitepaper];

/* INTERACCIÃ“N */
const ray=new THREE.Raycaster();
const mouse=new THREE.Vector2();
let hovered=null;

window.addEventListener("mousemove",e=>{
  mouse.x=e.clientX/innerWidth*2-1;
  mouse.y=-(e.clientY/innerHeight)*2+1;
});

window.addEventListener("click",()=>{
  if(hovered===roadmap) openPanel("roadmapPanel");
  if(hovered===tokenomics) openPanel("tokenomicsPanel");
  if(hovered===about) openPanel("aboutPanel");
  if(hovered===utility) openPanel("utilityPanel");
  if(hovered===security) openPanel("securityPanel");
  if (hovered === buyToken) {
    window.open("https://TU_LINK_DE_COMPRA", "_blank");
  }

  if (hovered === whitepaper) {
    window.open("whitepaper.pdf", "_blank");
  }

});

function openPanel(id){
  document.getElementById(id).style.display="block";
}
function closePanels(){
  document.querySelectorAll(".panel").forEach(p=>p.style.display="none");
}

/* ANIMACIÃ“N */
function animate(){
  // ğŸ¥ CINEMÃTICA DE ENTRADA
  if (!introFinished) {
  introProgress++;

  const t = introProgress / introDuration;
  const smoothT = t * t * (3 - 2 * t); // suavizado tipo cine

  camera.position.lerpVectors(introStart, introEnd, smoothT);
  camera.lookAt(0, 0, 0);

  if (t >= 1) {
    introFinished = true;
    controls.enabled = true; // activar ratÃ³n
  }
}

  clouds.rotation.y += 0.00008;
  clouds.rotation.x += 0.00003;

  requestAnimationFrame(animate);
  galaxy.rotation.y+=0.0004;
  nebula.rotation.y += 0.00005;

  ray.setFromCamera(mouse,camera);
  const hit=ray.intersectObjects(clickable);

  clickable.forEach(o=>o.scale.set(6,1.5,1));
  hovered=null;

  if(hit.length){
    hovered=hit[0].object;
    hovered.scale.set(6.8,1.7,1);
  }
  clickable.forEach(card => animateEntry(card));
  clickable.forEach(o=>o.lookAt(camera.position));
  controls.update();
  // âœ¨ TEXTO 3D SIEMPRE MIRANDO A CÃMARA
 if (window.title3D) {
  title3D.lookAt(camera.position);

  // Movimiento suave flotante
  title3D.position.y = 4.5 + Math.sin(Date.now() * 0.0015) * 0.2;
 }
  renderer.render(scene,camera);
}
function animateEntry(sprite, speed = 0.04) {
  if (sprite.userData.appear < 1) {
    sprite.userData.appear += speed;

    const t = Math.min(
      Math.max(sprite.userData.appear - sprite.userData.delay, 0),
      1
    );

    const eased = 1 - Math.pow(1 - t, 3); // ease-out
    const s = eased * 6;

    sprite.scale.set(s, s * 0.25, 1);
    sprite.material.opacity = eased;
  }
}


animate();clickable.forEach(card => {
  card.lookAt(camera.position);
});



window.addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
// ğŸ FINALIZAR APPLE EVENT
setTimeout(() => {
  const intro = document.getElementById("eventIntro");
  if (intro) intro.style.display = "none";
}, 6500);
// âœ¨ INTERACCIÃ“N DEL TÃTULO
const title = document.getElementById("mainTitle");

window.addEventListener("mousemove", (e) => {
  const x = (e.clientX / window.innerWidth - 0.5) * 20;
  const y = (e.clientY / window.innerHeight - 0.5) * 20;

  title.style.transform = `translate(${x}px, ${y}px)`;
});

</script>
</body>
</html>
