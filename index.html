<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mi Criptomoneda</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle at center, #05010a 0%, #000000 70%);
      font-family: Arial, sans-serif;
    }

    #ui {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: white;
      z-index: 10;
    }

    #ui h1 {
      font-size: 32px;
      margin: 0;
      letter-spacing: 3px;
    }

    #ui p {
      opacity: 0.7;
      margin-top: 5px;
    }
  </style>
</head>

<body>
  <div id="ui">
    <h1>MI CRIPTOMONEDA</h1>
    <p>Una galaxia financiera en expansiÃ³n</p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <script>
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.z = 12;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ðŸŒŒ GALAXIA
    const galaxyGeometry = new THREE.BufferGeometry();

    const starCount = 20000;
    const positions = [];
    const colors = [];

    const colorInside = new THREE.Color(0xffffff);
    const colorOutside = new THREE.Color(0x4b0082);

    const radius = 6;
    const branches = 4;
    const spin = 1;
    const randomness = 0.8;

    for (let i = 0; i < starCount; i++) {
      const r = Math.random() * radius;
      const branchAngle = (i % branches) / branches * Math.PI * 2;
      const spinAngle = r * spin;

      const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness;
      const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness;
      const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness;

      const x = Math.cos(branchAngle + spinAngle) * r + randomX;
      const y = randomY * 0.5;
      const z = Math.sin(branchAngle + spinAngle) * r + randomZ;

      positions.push(x, y, z);

      const mixedColor = colorInside.clone();
      mixedColor.lerp(colorOutside, r / radius);
      colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
    }

    galaxyGeometry.setAttribute(
      'position',
      new THREE.Float32BufferAttribute(positions, 3)
    );

    galaxyGeometry.setAttribute(
      'color',
      new THREE.Float32BufferAttribute(colors, 3)
    );

    const galaxyMaterial = new THREE.PointsMaterial({
      size: 0.03,
      sizeAttenuation: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true
    });

    const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
    scene.add(galaxy);

    // ðŸŒŸ LUCES SUAVES
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    // ðŸŒŒ ESTRELLAS DE FONDO
    const backgroundStarsGeometry = new THREE.BufferGeometry();
    const bgStars = 3000;
    const bgPositions = [];

    for (let i = 0; i < bgStars; i++) {
      bgPositions.push(
        (Math.random() - 0.5) * 300,
        (Math.random() - 0.5) * 300,
        (Math.random() - 0.5) * 300
      );
    }

    backgroundStarsGeometry.setAttribute(
      'position',
      new THREE.Float32BufferAttribute(bgPositions, 3)
    );

    const backgroundStarsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.6
    });

    const backgroundStars = new THREE.Points(backgroundStarsGeometry, backgroundStarsMaterial);
    scene.add(backgroundStars);

    // ðŸŽ¥ ANIMACIÃ“N
    function animate() {
      requestAnimationFrame(animate);

      galaxy.rotation.y += 0.0006;
      galaxy.rotation.z += 0.0003;

      backgroundStars.rotation.y += 0.0001;

      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
