<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Mi Criptomoneda</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: Arial, Helvetica, sans-serif;
      color: white;
    }

    #ui {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      z-index: 10;
      pointer-events: none;
    }

    #ui h1 {
      letter-spacing: 4px;
      margin: 0;
    }

    #ui p {
      opacity: 0.7;
      margin-top: 6px;
    }
  </style>
</head>

<body>
  <div id="ui">
    <h1>MI CRIPTOMONEDA</h1>
    <p>Una galaxia financiera en expansión</p>
  </div>

  <!-- THREE.JS CON MODULES (OBLIGATORIO EN GITHUB PAGES) -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js";
    import { EffectComposer } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/postprocessing/UnrealBloomPass.js";

    // ESCENA
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    // CÁMARA
    const camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      2000
    );
    camera.position.set(0, 6, 18);

    // RENDER
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 1.5;
    document.body.appendChild(renderer.domElement);

    // POSTPROCESADO CINEMATOGRÁFICO
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.6,
      0.4,
      0.1
    );
    composer.addPass(bloomPass);

    // CONTROLES
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.minDistance = 6;
    controls.maxDistance = 60;

    // LUCES
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const pointLight = new THREE.PointLight(0x88aaff, 2, 300);
    pointLight.position.set(10, 15, 10);
    scene.add(pointLight);

    // ======================
    // GALAXIA ESPIRAL REALISTA
    // ======================
    const galaxyGeometry = new THREE.BufferGeometry();
    const starCount = 120000;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);

    const insideColor = new THREE.Color(0xffffff);
    const outsideColor = new THREE.Color(0x3a66ff);

    const radius = 40;
    const branches = 4;
    const spin = 1.2;
    const randomness = 0.6;

    for (let i = 0; i < starCount; i++) {
      const i3 = i * 3;
      const r = Math.random() * radius;
      const branchAngle = (i % branches) / branches * Math.PI * 2;
      const spinAngle = r * spin;

      const randomX = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;
      const randomY = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness * 0.3 * r;
      const randomZ = Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1) * randomness * r;

      positions[i3]     = Math.cos(branchAngle + spinAngle) * r + randomX;
      positions[i3 + 1] = randomY;
      positions[i3 + 2] = Math.sin(branchAngle + spinAngle) * r + randomZ;

      const mixedColor = insideColor.clone().lerp(outsideColor, r / radius);
      colors[i3]     = mixedColor.r;
      colors[i3 + 1] = mixedColor.g;
      colors[i3 + 2] = mixedColor.b;
    }

    galaxyGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
    galaxyGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

    const galaxyMaterial = new THREE.PointsMaterial({
      size: 0.035,
      sizeAttenuation: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true
    });

    const galaxy = new THREE.Points(galaxyGeometry, galaxyMaterial);
    scene.add(galaxy);

    // NÚCLEO BRILLANTE
    const core = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 32, 32),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        emissive: 0x88ccff,
        emissiveIntensity: 3
      })
    );
    scene.add(core);

    // HALO
    const glow = new THREE.Mesh(
      new THREE.SphereGeometry(1.4, 32, 32),
      new THREE.MeshBasicMaterial({
        color: 0x88ccff,
        transparent: true,
        opacity: 0.25
      })
    );
    scene.add(glow);

    // ESTRELLAS DE FONDO
    const bgGeometry = new THREE.BufferGeometry();
    const bgPositions = new Float32Array(8000 * 3);
    for (let i = 0; i < bgPositions.length; i++) {
      bgPositions[i] = (Math.random() - 0.5) * 600;
    }
    bgGeometry.setAttribute("position", new THREE.BufferAttribute(bgPositions, 3));
    scene.add(new THREE.Points(
      bgGeometry,
      new THREE.PointsMaterial({ color: 0xffffff, size: 0.6 })
    ));

    // ANIMACIÓN
    function animate() {
      requestAnimationFrame(animate);

      galaxy.rotation.y += 0.0005;
      galaxy.rotation.z += 0.0002;

      const pulse = 1 + Math.sin(Date.now() * 0.002) * 0.1;
      core.scale.setScalar(pulse);
      glow.scale.setScalar(pulse * 1.5);

      controls.update();
      composer.render();
    }
    animate();

    // RESPONSIVE
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
